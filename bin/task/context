#! /bin/bash

# Usage:
#   context 1h2m30s (Update current context with given time)
#   context         (Check total time of each context)

LOG_FILE=~/log/.context && touch $LOG_FILE
context="$(cat ~/.task/context)"
time="$1"

# The unit of time display. For example:
# If it is 900(seconds), then the minimal symbol of 
# time display is 15min
UNIT=900
BLOCK_CHAR=â–Š
# This dictionary store the valid contexts and the time I plan to spend on
declare -A PLAN

# Get seconds from given string
_get_seconds() {
  # Modify input to fit the format that `date` can read
  hour=$(grep -o '[0-9.]\+h' <<<"$1" | tr -d '[:alpha:]')
  min=$(grep -o '[0-9.]\+m'  <<<"$1" | tr -d '[:alpha:]')
  sec=$(grep -o '[0-9.]\+s'  <<<"$1" | tr -d '[:alpha:]')
  echo "${hour:-0}*3600 + ${min:-0}*60 + ${sec:-0}" | bc | xargs printf '%.0f\n'
}

_set_context_plan() {
  while read line; do
    [ -z "$line" ] && break

    ctx=$(awk '{print $1}' <<<"$line")
    time=$(awk '{print $2}' <<<"$line")

    PLAN[$ctx]=$(_get_seconds $time)
  done <~/log/plan.context.md
}

# Update time of current context
if [ -n "$1" ]; then
  # If current conetxt is not given, exit with 1
  if [ -z "$context" ] || [ "$context" = none ]; then 
    exit 1
  fi

  given_seconds="$(_get_seconds "$time")"

  # Get total time of given time and current context time
  while read -r ctx sec; do
    if [ "$ctx" = "$context" ]; then
      total=$(( "$sec" + "$given_seconds" ))
      sed -i -E "s/^${context}.*/${context}\t${total}/" $LOG_FILE
      exit 0
    fi
  done <$LOG_FILE

  # Update Log file
  echo -e "$context\t${given_seconds}" >>$LOG_FILE
# Print times for each context
else
  _set_context_plan
  while read -r ctx sec; do
    # Print context and time I spend
    echo -ne "$ctx\t\t"
    date -u -d @"$sec" +%H:%M | tr -d '\n'

    number_of_spend=$(( $sec / $UNIT ))
    # Print block of time spend (green)
    echo -ne "\t\t\e[32m"
    [ ! "$number_of_spend" = 0 ] && printf "%0.s$BLOCK_CHAR" $(seq $number_of_spend)
    echo -en "\e[0m"

    seconds_of_plan=${PLAN[$ctx]}
    if [ -n "$seconds_of_plan" ]; then
      number_of_plan=$(( ${seconds_of_plan} / $UNIT ))
      [ "$(( $seconds_of_plan % $UNIT ))" = 0 ] || (( number_of_plan++ ))
      number_of_remaining=$(( $number_of_plan - $number_of_spend ))

      # Print block of remaining time (normal)
      if (( "$number_of_remaining" > 0 )); then
        printf "%0.s$BLOCK_CHAR" $(seq $number_of_remaining)
      # Print block of exceed time (red)
      elif (( "$number_of_remaining" < 0 )); then
        number_of_exceed=${number_of_remaining#-}
        printf "%0.s\b" $(seq $number_of_exceed)
        echo -ne "\e[31m"
        printf "%0.s$BLOCK_CHAR" $(seq $number_of_exceed)
        echo -en "\e[0m"
      fi
    fi
    echo
  done <$LOG_FILE
fi
