#! /bin/bash

# TODO
# - Use suggested block to wrap data:
#   https://help.openai.com/en/articles/6654000-best-practices-for-prompt-engineering-with-openai-api
# - Print token usage when exit

# Necessary commands
stacks=( curl jq )

# User can dynamically change these options for API call
configurable_options=( behavior temperature max_tokens )

# If script is interupt by SIGINT, simply print leave message
trap _print_leave_message INT

_check_stacks() {
  # Print all available options
  index=0
  for command in "${stacks[@]}"; do
    which "$command" &>/dev/null && continue
    echo "$command" is needed
    exit 1
  done
}

# Function for printing helper message
_print_helper_message() {
  cat <<EOF
Usage: gpt [-h] [-m MODEL] [-m4] [-b BEHAVIOR] [-t temperature]
           [-M MAX_TOKENS] [-s] [MESSAGE]

Env:
  OPENAI_API_KEY    (Required)
                    Generate API key from https://platform.openai.com/account/api-keys

Options:
  -h, --help        show this help message and exit

  -m|--model        specify model, available:
                    gpt-4, gpt-4-0314, gpt-4-32k, gpt-4-32k-0314, 
                    gpt-3.5-turbo, gpt-3.5-turbo-0301
                    (Defaults to gpt-3.5-turbo)

  -m4               Use model gpt-4 
                    
  -b|--behavior     How model behave on response, for example:
                      "You are a helpful assistant."
                    (Defaults to "You are a helpful programming assistant")

  -t|--temperature  Value between 0 and 2. Higher values like 0.8 will make the 
                    output more random, while lower values like 0.2 will make it 
                    more focused and deterministic.
                    (Defaults to 0.7)

  -M|--max_tokens   The maximum number of tokens to generate in the completion.
                    (Defaults to 2048)

  -s|--skip         Skip message, STDIN would be treated as your message

  *                 The other arguments would be treated as message content.
                    If no message is specified, user should input content by hands.
                    If STDIN is given, it would be append to the end of message.

Special prompt:
  Options           If input starts with '.', then a prompt of options shows up. 
                    User can modify option value for API calls.

Reference: https://platform.openai.com/docs/api-reference/completions
EOF
}

_print_leave_message(){
  echo -e "\nChat Finished, cached file: $cache"
  exit 0
}

# A prompt for option configuration
_configure_options() {
  # Apply original trap action, and exit this prompt
  trap 'trap _print_leave_message SIGINT; echo; return' INT
  # Hint message
  echo 'List of options: (Use Ctrl-C to exit)'

  # Print all available options
  index=0
  for option in "${configurable_options[@]}"; do
    echo -e "$index." "$option:\t" "$(eval "echo \$$option")"
    (( index+=1 ))
  done

  # Prompt for user input
  while true; do
    echo
    read -e -r -p "Modify which option? (0~$((index-1))) " selection
    local field=${configurable_options[$selection]}
    eval "read -e -r -p '$field: ' $field"
  done
}

# Get latest content for completion
_get_content() {

  # Read data from STDIN
  [ ! -t 0 ] && data="$(cat)"

  if [ ! "$SKIP_INPUT" = true ] ; then
    # Read content it from terminal
    while true; do
      read -e -r -p "Let's Chat: " content </dev/tty
      [[ "$content" =~ ^\. ]] && echo && _configure_options && echo -e '\n------\n' && continue
      [ -n "$content" ] && break
    done
  elif [[ "$count" -eq 0 && -z "$data" ]]; then
    echo -e "No data from STDIN\n"
    exit 1;
  fi

  # If it is the first round, append STDIN (If it exists) at the end
  if [[ ! "$SKIP_INPUT" = true && -n "$data" ]] ; then
    content="$(printf "%s\\n\\n%s" "$content" "$data")"
    echo -e "\n$data"
  # Or only use STDIN as content
  elif [ -n "$data" ]; then
    content="$data"
    echo "$content"
  fi
}

# Check OPENAI API KEY"Department:" 3 1 "" 3 15 25 0
[ -z "$OPENAI_API_KEY" ] && which token &>/dev/null && OPENAI_API_KEY=$(token openai)
[ -z "$OPENAI_API_KEY" ] && { echo API KEY not specified; exit 1; }

# Parse arguments
while [ "$#" -gt 0 ]; do
  case "$1" in
    -m|--model)
      model="$2"
      shift 2
      ;;
    -m4)
      model="gpt-4"
      shift 1
      ;;
    -b|--behavior)
      behavior="$2"
      shift 2
      ;;
    -t|--temperature)
      temperature="$2"
      shift 2
      ;;
    -M|--max_tokens)
      max_tokens="$2"
      shift 2
      ;;
    -s|--skip)
      SKIP_INPUT=true
      shift 1
      ;;
    -h|--help)
      _print_helper_message
      exit 0
      ;;
    *)
      SKIP_INPUT=true
      content="$1"
      shift 1
      ;;
  esac
done

# Make sure necessary commands exist
_check_stacks

# Set variables in API calls
ROUTE=v1/chat/completions
model=${model:-gpt-3.5-turbo}
behavior="${behavior:-You are a helpful programming assistant}"
temperature=${temperature:-0.7}
max_tokens=${max_tokens:-2048}

# Prepare for chat session
cache=$(mktemp) && touch "$cache" 
#trap "rm $cache" EXIT
session=()
count=0

# Use while to keep chat session
while true; do
  _get_content

  # User must input by hands in the following rounds
  SKIP_INPUT=false

  # Put user message into session
  user_message="$(cat <<EOF
{"role": "user", "content": $(printf '%s' "$content" | jq -sR .)}
EOF
  )"
  session+=("$user_message")

  # Create request body
  # Consider quotes, back slashes, use jq to ensure content texts are OK to put in JSON
  body="$(cat <<EOF
{
   "model": "$model",
   "messages": [
     {"role": "system", "content": $(echo "$behavior" | jq -sR .)},
     $(IFS=','; echo "${session[*]}")
   ],
   "temperature": $temperature,
   "max_tokens": $max_tokens
}
EOF
  )"
  # Append request body into cache
  echo "$body" >>"$cache"

  # Add an empty line between prompt and response
  echo -e '\n------\n'

  # API call
  # Save original response into cache file
  # And only print content of message
  response="$(
    curl https://api.openai.com/$ROUTE \
      --silent \
      -H "Content-Type: application/json" \
      -H "Authorization: Bearer $OPENAI_API_KEY" \
      -d "$body" | \
    jq . | tee -a "$cache" | \
    jq -r .choices[0].message.content
  )"
  echo -e "${response}\n\n------\n"

  # Append newest message into session
  assistant_message="$(cat <<EOF
{"role": "assistant", "content": $(<<<"$response" jq -sR .)}
EOF
  )"
  session+=("$assistant_message")

  (( count+=1 ))
done
